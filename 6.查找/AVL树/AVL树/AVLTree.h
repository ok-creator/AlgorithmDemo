/*
	AVL树的实现文件
	四种情况的旋转最好参照图片，否则难以理解
*/
#pragma once
#include<iostream>
#include<iomanip>
using namespace std;

template<class T>
class AVLTreeNode		//AVL树节点
{
public:
	T key;				//关键字（键值）
	int height;			//高度
	AVLTreeNode *left;	//左孩子
	AVLTreeNode *right;	//右孩子
	AVLTreeNode(T value, AVLTreeNode *l,AVLTreeNode *r):
		key(value),height(0),left(l),right(r){}
};

//AVL树
template<class T>
class AVLTree
{
private:
	AVLTreeNode<T> *mRoot;		//根节点
public:
	AVLTree();
	~AVLTree();
	int height();				//获取树的高度
	int max(int a, int b);		//获取两个数中的最大值

	void preOrder();
	void inOrder();
	void postOrder();

	AVLTreeNode<T>* search(T key);
	AVLTreeNode<T>* iterativeSearch(T key);

	T minimum();
	T maximum();

	void insert(T key);
	void remove(T key);

	void destroy();
	void print();
private:
	int height(AVLTreeNode<T>* tree);		//获取树的高度

	void preOrder(AVLTreeNode<T> *tree)const;
	void inOrder(AVLTreeNode<T> *tree)const;
	void postOrder(AVLTreeNode<T> *tree)const;

	AVLTreeNode<T>* search(AVLTreeNode<T>* x, T key)const;
	AVLTreeNode<T>* iterativeSearch(AVLTreeNode<T>* x, T key)const;

	AVLTreeNode<T>* minimum(AVLTreeNode<T>* tree);
	AVLTreeNode<T>* maximum(AVLTreeNode<T>* tree);

	//LL: 左左对应的情况（左单旋转）
	AVLTreeNode<T>* leftLeftRotation(AVLTreeNode<T> *k2);

	//RR:右右对应的情况（右单旋转）
	AVLTreeNode<T>* rightRightRotation(AVLTreeNode<T> *k1);

	//LR：左右对应的情况（左双旋转）
	AVLTreeNode<T>* leftRightRotation(AVLTreeNode<T> *k3);

	//RL:右左对应的情况（右双旋转）
	AVLTreeNode<T>* rightLeftRotation(AVLTreeNode<T>* k1);
	//将节点插入到AVL树中
	AVLTreeNode<T>* insert(AVLTreeNode<T>* &tree, T key);
	//删除AVL树中的结点，并返回被删除的结点
	AVLTreeNode<T>* remove(AVLTreeNode<T>* &tree, AVLTreeNode<T> *z);
	//销毁AVL树
	void destroy(AVLTreeNode<T>* &tree);
	//打印AVL树
	void print(AVLTreeNode<T> *tree, T key, int drirection);
};

//构造函数
template <class T>
AVLTree<T>::AVLTree() :mRoot(NULL)
{
}

//析构函数
template <class T>
AVLTree<T>::~AVLTree()
{
     destroy(mRoot);
}

//获取树的高度
template<class T>
int AVLTree<T>::height(AVLTreeNode<T> *tree)
{
	if (tree != NULL)		//树不为空
		return tree->height;//直接返回树的高度参数

	return 0;				//否则空二叉树高度返回0
}

template<class T>
int AVLTree<T>::height()
{
	return height(mRoot);
}

//比较两个值的大小
template<class T>
int AVLTree<T>::max(int a, int b)
{
	return a > b ? a : b;
}

//前序遍历AVL树
template <class T>
void AVLTree<T>::preOrder(AVLTreeNode<T>* tree) const
{
	if (tree != NULL)
	{
		cout << tree->key << " ";
		preOrder(tree->left);
		preOrder(tree->right);
	}
}

template <class T>
void AVLTree<T>::preOrder()
{
   preOrder(mRoot);
}

//中序遍历AVL树
template <class T>
void AVLTree<T>::inOrder(AVLTreeNode<T>* tree) const
{
     if (tree != NULL)
     {
         inOrder(tree->left);
         cout << tree->key << " ";
         inOrder(tree->right);
     }
}

template <class T>
void AVLTree<T>::inOrder()
{
     inOrder(mRoot);
}

//后序遍历AVL树
template <class T>
void AVLTree<T>::postOrder(AVLTreeNode<T>* tree) const
{
     if (tree != NULL)
     {
         postOrder(tree->left);
         postOrder(tree->right);
         cout << tree->key << " ";
     }
}

template <class T>
void AVLTree<T>::postOrder()
{
     postOrder(mRoot);
}

//（递归实现）查找AVL树中键值为key的节点
template <class T>
AVLTreeNode<T>* AVLTree<T>::search(AVLTreeNode<T>* x, T key) const
{
     if (x == NULL || x->key == key)
         return x;

     if (key < x->key)
         return search(x->left, key);
     else
         return search(x->right, key);
}

template <class T>
AVLTreeNode<T>* AVLTree<T>::search(T key)
{
     return search(mRoot, key);
}

/*
  * (非递归实现)查找"AVL树x"中键值为key的节点
*/
template <class T>
AVLTreeNode<T>* AVLTree<T>::iterativeSearch(AVLTreeNode<T>* x, T key) const
{
     while ((x != NULL) && (x->key != key))
     {
         if (key < x->key)
             x = x->left;
         else
             x = x->right;
     }

     return x;
}

template <class T>
AVLTreeNode<T>* AVLTree<T>::iterativeSearch(T key)
{
     return iterativeSearch(mRoot, key);
}

//查找最小节点：返回tree为根节点的AVL树的最小结点
template <class T>
AVLTreeNode<T>* AVLTree<T>::minimum(AVLTreeNode<T>* tree)
{
     if (tree == NULL)
         return NULL;

     while (tree->left != NULL)
         tree = tree->left;
     return tree;
}

template <class T>
T AVLTree<T>::minimum()
{
     AVLTreeNode<T> *p = minimum(mRoot);
     if (p != NULL)
         return p->key;

     return (T)NULL;
}

//查找最大结点：返回tree为根节点的AVL树的最大结点
template <class T>
AVLTreeNode<T>* AVLTree<T>::maximum(AVLTreeNode<T>* tree)
{
     if (tree == NULL)
         return NULL;

     while (tree->right != NULL)
         tree = tree->right;
     return tree;
}

template <class T>
T AVLTree<T>::maximum()
{
	AVLTreeNode<T> *p = maximum(mRoot);
	if (p != NULL)
		return p->key;

	return (T)NULL;
}

/*	LL :左左对应的情况（左单旋转）
	返回值：旋转后的根节点
		LL旋转是围绕"失去平衡的AVL根节点"进行的，也就是节点k2；而且由于
		是LL情况，即左左情况，就用手抓着"左孩子，即k1"使劲摇。将k1变成根
		节点，k2变成k1的右子树，"k1的右子树"变成"k2的左子树
*/
template<class T>
AVLTreeNode<T>* AVLTree<T>::leftLeftRotation(AVLTreeNode<T>* k2)
{
	AVLTreeNode<T> *k1;		//定义临时节点
	k1 = k2->left;			//将k2的左孩子保存在k1中
	k2->left = k1->right;	//将k1的右孩子变成k2的左孩子
	k1->right = k2;			//将k2变成k1的右孩子

	k2->height = max(height(k2->left), height(k2->right)) + 1;
	k1->height = max(height(k1->left), k2->height) + 1;

	return k1;				//返回调整之后的根节点
}

//RR：右右对应的情况（右单旋转）
//返回值：旋转后的根节点
template<class T>
AVLTreeNode<T>* AVLTree<T>::rightRightRotation(AVLTreeNode<T>* k1)
{
	AVLTreeNode<T>* k2;
	k2 = k1->right;
	k1->right = k2->left;
	k2->left = k1;

	k1->height = max(height(k1->left), height(k1->right)) + 1;
	k2->height = max(height(k2->right), k1->height)+1;

	return k2;
}

//LR：左右对应的情况(左双旋转)
//返回值：旋转后的根节点
template<class T>
AVLTreeNode<T>* AVLTree<T>::leftRightRotation(AVLTreeNode<T>* k3)
{
	//先对k3的左孩子进行右右旋转，其结果仍然是k3的左孩子
	k3->left = rightRightRotation(k3->left);	
	//再对k3进行左左旋转，并返回
	return leftLeftRotation(k3);
}

//RL：右左对应的情况（右双旋转）
//返回值：旋转后的根节点
template<class T>
AVLTreeNode<T>* AVLTree<T>::rightLeftRotation(AVLTreeNode<T> *k1)
{
	k1->right = leftLeftRotation(k1->right);

	return rightRightRotation(k1);
}

/*
	将节点插入到AVL树中，并返回根节点
	参数说明：
		tree AVL树的根节点
		key	 插入的节点的键值
	返回值：
		根节点
*/
template<class T>
AVLTreeNode<T>* AVLTree<T>::insert(AVLTreeNode<T>* &tree, T key)
{
	if (tree == NULL)
	{
		//如果根节点为空，则新建节点，用构造函数初始化
		tree = new AVLTreeNode<T>(key, NULL, NULL);
		if (tree == NULL)
		{
			cout << "ERROR:create avltree node failed!" << endl;
			return NULL;
		}
	}
	else if (key < tree->key)
	{
		//小于当前结点，在其左节点上进行插入
		tree->left = insert(tree->left, key);
		//插入完成之后，判断是否发生不平衡
		if (height(tree->left) - height(tree->right) == 2)
		{
			//判断插入的位置，如果在左孩子的左端插入，则调用LL
			//否则在左孩子的右端插入，调用LR
			if (key < tree->left->key)
				tree = leftLeftRotation(tree);
			else
				tree = leftRightRotation(tree);
		}
	}
	else if (key>tree->key)
	{
		tree->right = insert(tree->right, key);
		if (height(tree->right) - height(tree->left) == 2)
		{
			if (key > tree->right->key)
				tree = rightRightRotation(tree);
			else
				tree = rightLeftRotation(tree);
		}
	}
	else		//节点值与当前结点的值相同，插入失败
	{
		cout << "添加失败：不允许添加相同的节点！" << endl;
	}
	tree->height = max(height(tree->left), height(tree->right)) + 1;
	return tree;
}

template<class T>
void AVLTree<T>::insert(T key)
{
	insert(mRoot, key);		//在根节点插入键值
}

/*
	删除节点（z),返回根节点
	参数说明：
		tree	AVL树的根节点
		z		待删除的节点
	返回值：
		根节点
*/
template<class T>
AVLTreeNode<T>* AVLTree<T>::remove(AVLTreeNode<T>* &tree, AVLTreeNode<T> *z)
{
	//跟为空 或者 没有要删除的节点，直接返回NULL
	if (tree == NULL || z == NULL)
		return NULL;
	if (z->key < tree->key)		//待删除的节点在tree的左子树中
	{
		tree->left = remove(tree->left, z);
		//删除节点后，若AVL树失去平衡
		if (height(tree->right) - height(tree->left) == 2)
		{
			//定义临时节点为树的右节点
			AVLTreeNode<T> *r = tree->right;
			if (height(r->left)>height(r->right))
				tree = rightLeftRotation(tree);
			else
				tree = rightRightRotation(tree);
		}
	}
	else if(z->key>tree->key)	//待删除的节点在tree的右子树中
	{
		tree->right = remove(tree->right, z);
		if (height(tree->left) - height(tree->right) == 2)
		{
			AVLTreeNode<T>* l = tree->left;
			if (height(l->right) > height(l->left))
				tree = leftRightRotation(tree);
			else
				tree = leftLeftRotation(tree);
		}
	}
	else		//tree是对应要删除的节点
	{
		//如果树的左孩子都非空
		if ((tree->left != NULL) && (tree->right != NULL))
		{
			//如果tree的左子树比右子树高
			//则(01）找出tree的左子树中的最大结点
			//（02）将该最大结点的值赋给tree
			//（03）删除该最大结点
			//这种类似于用tree的左子树中最大节点做tree的替身
			//采用这种方式的好处是：删除tree中的左子树中的最大节点后，AVL树依然是平衡的
			if (height(tree->left) > height(tree->right))
			{
				AVLTreeNode<T> *max = maximum(tree->left);
				tree->key = max->key;
				tree->left = remove(tree->left, max);
			}
			else
			{
				// 如果tree的左子树不比右子树高(即它们相等，或右子树比左子树高1)
				// 则(01)找出tree的右子树中的最小节点
				//   (02)将该最小节点的值赋值给tree。
				//   (03)删除该最小节点。
				// 这类似于用"tree的右子树中最小节点"做"tree"的替身；
				// 采用这种方式的好处是：删除"tree的右子树中最小节点"之后，AVL树仍然是平衡的。
				AVLTreeNode<T>* min = maximum(tree->right);
				tree->key = min->key;
				tree->right = remove(tree->right, min);
			}
		}
		else	//本身是平衡树，所以左右孩子差距为1，其中一个高度为0，另一个高度必然为1
		{
			AVLTreeNode<T>* tmp = tree;
			tree = (tree->left != NULL) ? tree->left : tree->right;
			delete tmp;
		}
	}
	return tree;
}

template<class T>
void AVLTree<T>::remove(T key)
{
	AVLTreeNode<T>* z;

	if ((z = search(mRoot, key)) != NULL)
		mRoot = remove(mRoot, z);
}

/*
	* 销毁AVL树
*/
template <class T>
void AVLTree<T>::destroy(AVLTreeNode<T>* &tree)
{
    if (tree == NULL)
        return;

    if (tree->left != NULL)
        destroy(tree->left);
    if (tree->right != NULL)
        destroy(tree->right);

	delete tree;
 }

//销毁AVL树
template <class T>
void AVLTree<T>::destroy()
{
	 destroy(mRoot);
}

/*
	* 打印"二叉查找树"
	*
	* key        -- 节点的键值
	* direction  --  0，表示该节点是根节点;
	*               -1，表示该节点是它的父结点的左孩子;
	*                1，表示该节点是它的父结点的右孩子。
*/
template <class T>
void AVLTree<T>::print(AVLTreeNode<T>* tree, T key, int direction)
{
	if (tree != NULL)		//判断当前结点是否为空
	{
		if (direction == 0)    // tree是根节点
			cout << setw(2) << tree->key << " is root" << endl;
		else                // tree是分支节点
			cout << setw(2) << tree->key << " is " << setw(2) << key << "'s " << setw(12) << (direction == 1 ? "right child" : "left child") << endl;
		
		print(tree->left, tree->key, -1);
		print(tree->right, tree->key, 1);
	}
}

template <class T>
void AVLTree<T>::print()
{
	if (mRoot != NULL)
		print(mRoot, mRoot->key, 0);
}